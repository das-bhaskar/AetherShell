# AetherShell Developer Log 011

## Project AetherShell: End-to-End Vision Relay & iOS Asset Synchronization

**Version:** 1.7  
**Date:** 2026-01-16  
**Subject:** Resolving Static Resource Mapping and Multi-Platform Data Integrity for iOS Animation

---

## 1. Executive Summary

Log 011 documents the final "handshake" between the Python rendering engine, the Java Spring Hub, and the SwiftUI client. The primary challenge transitioned from simple connectivity to **Dynamic Asset Visibility**. This log details the resolution of a critical "Loading Loop" on iOS caused by Spring Boot’s static resource caching and the implementation of a deterministic polling mechanism that successfully delivers animated NDS sketches to an iPhone via Cloudflare.

---

## 2. The "Stuck on Loading" Challenge

During integration, the iOS app remained in a perpetual loading state despite the backend functioning correctly. We identified three specific failure points in the data pipeline:

1.  **Static Resource Blindness:** Spring Boot’s default configuration only scans the `/static` folder at startup. Files generated mid-runtime by the Python Worker were invisible to the web server, resulting in `404 Not Found` errors even though the files existed on disk.
2.  **Path Mismatch:** The naming convention produced by the renderer (`{session_id}_frame_n.png`) required a specific URL routing prefix (`/output/`) to distinguish static assets from API endpoints.
3.  **JSON Key Desynchronization:** A mismatch between the Python return key (`images`) and the iOS expected key (`image_paths`) prevented the Swift client from identifying the asset list.

---

## 3. Technical Implementation Details

### A. Dynamic Resource Handler Override

To ensure the iPhone could access frames immediately after they were drawn, I implemented a `WebConfig` that bypasses the internal classpath cache and maps directly to the physical filesystem on the Mac.

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    String rootPath = System.getProperty("user.dir");
    String finalPath = "file:" + rootPath + "/hub/src/main/resources/static/output/";

    registry.addResourceHandler("/output/**")
            .addResourceLocations(finalPath)
            .setCachePeriod(0); // Forces fresh disk read per request
}
```

---

### B. The iOS Polling & Download Engine

The SwiftUI logic was refactored into a `FrameViewModel` that utilizes `DispatchGroup` to synchronize the download of multiple frames before toggling the UI state.

- **Polling Frequency**: 2.0s intervals via `Timer` to check the `/session/results/{id}` endpoint
- **State Transition**: The `isLoading` flag is only set to false once the `DispatchGroup.notify` block confirms all PNG assets are locally cached in memory as `UIImage` objects.

---

### 4. Technical Performance Table

| Metric           | Technical Implementation                    | Result                                               |
| ---------------- | ------------------------------------------- | ---------------------------------------------------- |
| Asset Discovery  | Runtime FileSystem Resource Mapping         | 0ms delay between Python render and Web availability |
| Data Integrity   | Session-ID Prefixed Filenames               | Zero collisions between concurrent user sessions     |
| Polling Strategy | JSON `status` check (processing vs success) | Minimal battery drain on iOS device                  |
| Animation Loop   | SwiftUI `onReceive` + Index Cycling         | Smooth 10fps playback of NDS strokes                 |
| Bandwidth        | PNG Compression + Cloudflare QUIC           | Fast loading even on cellular 5G data                |

---

### 5. End-to-End Workflow Recap

1. **NDS Ingestion**: Java Hub receives coordinates on Port 8080 via legacy WiFi.
2. **Python Processing**: Worker renders PNGs with a session-prefixed naming convention (e.g., `890c05fe_frame_0.png`).
3. **Spring Bridge**: Hub stores the worker's result in a `ConcurrentHashMap` and exposes the directory via the `/output/` handler.
4. **iOS Polling**: iPhone app hits `/session/results/{id}` via the Cloudflare Tunnel on Port 8443.
5. **Asset Retrieval**: Upon a success status, the app downloads all images in the `images` array and begins the animation loop.

---

### 6. Key Technical Decisions

- **Cache-Control: zero**  
  Explicitly disabled server-side caching to prevent the iPhone from seeing old sketches when a session ID is reused or when testing rapidly.

- **Absolute Path Resolution**  
  Used `System.getProperty("user.dir")` to ensure the project remains portable between development environments without breaking the file-serving logic.

- **Single-Source-of-Truth Names**  
  The Python script determines the final filenames, which are then passed verbatim through Java to the iOS app, eliminating hardcoded string errors.

---

### 7. Summary

Log 011 marks the transition from a "working backend" to a "working product." The animation of NDS frames on the iPhone confirms that the bridge is fully bidirectional and synchronized. We have overcome the "Semantic Gap" (Log 009), the "NAT/Public Gap" (Log 010), and finally the "Static Resource Gap" (Log 011).

AetherShell is now a functional multimodal AR pipeline.
